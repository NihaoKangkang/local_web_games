const snakeLevels = [[
  
],
[
  [5,9],
  [6,9],
  [7,9],
  [8,9],
  [9,9],
  [10,9],
  [11,9],
  [12,9],
  [13,9],
  [14,9]
],
[
  [5,3],
  [5,4],
  [5,5],
  [5,6],
  [5,7],
  [5,8],
  [5,9],
  [5,10],
  [5,11],
  [5,12],
  [5,13],
  [5,14],
  [5,15],
  [14,3],
  [14,4],
  [14,5],
  [14,6],
  [14,7],
  [14,8],
  [14,9],
  [14,10],
  [14,11],
  [14,12],
  [14,13],
  [14,14],
  [14,15]
],
[
  [0,14],
  [1,14],
  [2,14],
  [3,14],
  [4,14],
  [5,1],
  [5,2],
  [5,3],
  [5,4],
  [5,5],
  [5,6],
  [5,7],
  [5,8],
  [5,9],
  [5,10],
  [5,11],
  [5,14],
  [6,14],
  [7,14],
  [8,14],
  [9,14],
  [10,5],
  [11,5],
  [12,5],
  [13,5],
  [14,5],
  [14,9],
  [14,10],
  [14,11],
  [14,12],
  [14,13],
  [14,14],
  [14,15],
  [14,16],
  [14,17],
  [14,18],
  [14,19],
  [15,5],
  [16,5],
  [17,5],
  [18,5],
  [19,5]
],
[
  [5,4],
  [5,5],
  [5,6],
  [5,7],
  [5,8],
  [5,9],
  [5,10],
  [5,11],
  [5,12],
  [5,13],
  [5,14],
  [5,15],
  [5,16],
  [6,4],
  [6,16],
  [7,4],
  [7,16],
  [8,4],
  [8,16],
  [9,4],
  [9,16],
  [10,4],
  [10,16],
  [11,4],
  [11,16],
  [12,4],
  [12,16],
  [13,4],
  [13,16],
  [14,5],
  [14,6],
  [14,7],
  [14,8],
  [14,9],
  [14,10],
  [14,11],
  [14,12],
  [14,13],
  [14,14],
  [14,15]
],
[
  [2,1],
  [2,2],
  [2,3],
  [2,4],
  [2,5],
  [2,6],
  [2,7],
  [2,8],
  [2,12],
  [2,13],
  [2,14],
  [2,15],
  [2,16],
  [2,17],
  [2,18],
  [2,19],
  [5,1],
  [5,2],
  [5,3],
  [5,4],
  [5,5],
  [5,6],
  [5,7],
  [5,8],
  [5,12],
  [5,13],
  [5,14],
  [5,15],
  [5,16],
  [5,17],
  [5,18],
  [5,19],
  [7,1],
  [7,2],
  [7,3],
  [7,4],
  [7,5],
  [7,6],
  [7,7],
  [7,8],
  [7,12],
  [7,13],
  [7,14],
  [7,15],
  [7,16],
  [7,17],
  [7,18],
  [7,19],
  [9,1],
  [9,2],
  [9,3],
  [9,4],
  [9,5],
  [9,6],
  [9,7],
  [9,8],
  [9,12],
  [9,13],
  [9,14],
  [9,15],
  [9,16],
  [9,17],
  [9,18],
  [9,19],
  [12,1],
  [12,2],
  [12,3],
  [12,4],
  [12,5],
  [12,6],
  [12,7],
  [12,8],
  [12,12],
  [12,13],
  [12,14],
  [12,15],
  [12,16],
  [12,17],
  [12,18],
  [12,19],
  [14,1],
  [14,2],
  [14,3],
  [14,4],
  [14,5],
  [14,6],
  [14,7],
  [14,8],
  [14,12],
  [14,13],
  [14,14],
  [14,15],
  [14,16],
  [14,17],
  [14,18],
  [14,19],
  [17,1],
  [17,2],
  [17,3],
  [17,4],
  [17,5],
  [17,6],
  [17,7],
  [17,8],
  [17,12],
  [17,13],
  [17,14],
  [17,15],
  [17,16],
  [17,17],
  [17,18],
  [17,19]
],
[
  [9,1],
  [9,2],
  [9,3],
  [9,4],
  [9,5],
  [9,6],
  [9,7],
  [9,8],
  [9,9],
  [9,10],
  [9,11],
  [9,12],
  [9,13],
  [9,14],
  [9,15],
  [9,16],
  [9,17],
  [9,18]
],
[
  [2,1],
  [2,2],
  [2,3],
  [2,4],
  [2,5],
  [2,6],
  [2,7],
  [2,8],
  [2,9],
  [2,10],
  [2,11],
  [2,12],
  [2,13],
  [2,14],
  [2,15],
  [5,5],
  [5,6],
  [5,7],
  [5,8],
  [5,9],
  [5,10],
  [5,11],
  [5,12],
  [5,13],
  [5,14],
  [5,15],
  [5,16],
  [5,17],
  [5,18],
  [5,19],
  [7,1],
  [7,2],
  [7,3],
  [7,4],
  [7,5],
  [7,6],
  [7,7],
  [7,8],
  [7,9],
  [7,10],
  [7,11],
  [7,12],
  [7,13],
  [7,14],
  [7,15],
  [9,5],
  [9,6],
  [9,7],
  [9,8],
  [9,9],
  [9,10],
  [9,11],
  [9,12],
  [9,13],
  [9,14],
  [9,15],
  [9,16],
  [9,17],
  [9,18],
  [9,19],
  [12,1],
  [12,2],
  [12,3],
  [12,4],
  [12,5],
  [12,6],
  [12,7],
  [12,8],
  [12,9],
  [12,10],
  [12,11],
  [12,12],
  [12,13],
  [12,14],
  [12,15],
  [14,5],
  [14,6],
  [14,7],
  [14,8],
  [14,9],
  [14,10],
  [14,11],
  [14,12],
  [14,13],
  [14,14],
  [14,15],
  [14,16],
  [14,17],
  [14,18],
  [14,19],
  [17,1],
  [17,2],
  [17,3],
  [17,4],
  [17,5],
  [17,6],
  [17,7],
  [17,8],
  [17,9],
  [17,10],
  [17,11],
  [17,12],
  [17,13],
  [17,14],
  [17,15]
],
[
  [1,2],
  [2,3],
  [2,4],
  [3,4],
  [3,5],
  [4,6],
  [4,7],
  [5,7],
  [5,8],
  [5,9],
  [6,9],
  [6,10],
  [7,11],
  [7,12],
  [8,2],
  [8,3],
  [8,12],
  [8,13],
  [8,14],
  [9,3],
  [9,4],
  [9,14],
  [9,15],
  [10,5],
  [10,6],
  [10,16],
  [10,17],
  [11,6],
  [11,7],
  [11,17],
  [11,18],
  [12,8],
  [12,9],
  [13,9],
  [13,10],
  [13,11],
  [14,11],
  [14,12],
  [15,13],
  [15,14],
  [16,14],
  [16,15],
  [16,16],
  [17,16],
  [17,17],
  [18,17],
  [18,18]
]
];

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusText = document.getElementById('statusText');
const hintText = document.getElementById('hintText');
const legend = document.getElementById('legend');
const resetBtn = document.getElementById('resetBtn');
const rulesBtn = document.getElementById('rulesBtn');
const rulePanel = document.getElementById('rulePanel');
const ruleBody = document.getElementById('ruleBody');
const closeRule = document.getElementById('closeRule');
const snakeControls = document.getElementById('snakeControls');
const snakeSpeedControl = document.getElementById('snakeSpeedControl');
const snakeSpeedInput = document.getElementById('snakeSpeed');
const snakeSpeedValue = document.getElementById('snakeSpeedValue');
const snakeMapControl = document.getElementById('snakeMapControl');
const snakeMapSelect = document.getElementById('snakeMap');
const canvasWrap = document.querySelector('.canvas-wrap');
const gameArea = document.querySelector('.game-area');
const sideInfo = document.querySelector('.side-info');
const topbar = document.querySelector('.topbar');
const mainPanel = document.querySelector('.panel');
const panelHeader = document.querySelector('.panel-header');

const rules = `ÁÇπÂáªÊ£ãÁõòÂºÄÂßãÔºå‰ΩøÁî®ÊñπÂêëÈîÆÊàñÊªëÂä®ÊéßÂà∂ËõáÁßªÂä®„ÄÇ
ÂêÉÂà∞È£üÁâ©‰ºöÂèòÈïøÔºåÊíûÂà∞Â¢ôÊàñËá™Â∑±ÂàôÊ∏∏ÊàèÁªìÊùüÔºåÂèØÁ©øË∂äËæπÁïå„ÄÇ`;

let snakeTimer = null;
let touchStart = null;

function setCanvasSize() {
  const areaRect = gameArea.getBoundingClientRect();
  const infoRect = sideInfo.getBoundingClientRect();
  const topRect = topbar.getBoundingClientRect();
  const areaStyles = getComputedStyle(gameArea);
  const panelStyles = getComputedStyle(mainPanel);
  const columnGap = parseFloat(areaStyles.columnGap || areaStyles.gap || 0);
  const rowGap = parseFloat(panelStyles.rowGap || panelStyles.gap || 0);
  const panelPaddingTop = parseFloat(panelStyles.paddingTop || 0);
  const panelPaddingBottom = parseFloat(panelStyles.paddingBottom || 0);
  const headerRect = panelHeader.getBoundingClientRect();
  const availableWidth = areaRect.width - infoRect.width - columnGap;
  const stacked = availableWidth <= 0;
  const viewportHeight = document.documentElement.clientHeight;
  const panelHeight = viewportHeight - topRect.height - panelPaddingTop - panelPaddingBottom - 64;
  const contentHeight = panelHeight - headerRect.height - rowGap;
  const heightLimit = stacked ? contentHeight - infoRect.height - columnGap : contentHeight;
  const baseSize = Math.min(stacked ? areaRect.width : availableWidth, heightLimit, areaRect.height);
  const size = Math.max(220, Math.floor(baseSize));
  if (!Number.isFinite(size) || size <= 0) return;
  canvasWrap.style.width = `${size}px`;
  canvasWrap.style.height = `${size}px`;
  canvas.width = size;
  canvas.height = size;
}

window.addEventListener('resize', () => {
  setCanvasSize();
  draw();
});

const snake = {
  grid: 20,
  body: [],
  dir: { x: 1, y: 0 },
  nextDir: { x: 1, y: 0 },
  food: { x: 10, y: 10 },
  over: false,
  score: 0,
  running: false,
  speedValue: 140,
  speedDelay: 140,
  levelIndex: 0,
  walls: new Set(),
  bonus: {
    active: false,
    x: 0,
    y: 0,
    ttl: 0,
    maxTtl: 0
  },
  bonusCooldown: 0
};

function initSnake() {
  snake.walls = buildSnakeWalls(snake.levelIndex);
  const spawn = findSnakeSpawn();
  snake.body = [
    { x: spawn.x + 2, y: spawn.y },
    { x: spawn.x + 1, y: spawn.y },
    { x: spawn.x, y: spawn.y }
  ];
  snake.dir = { x: 1, y: 0 };
  snake.nextDir = { x: 1, y: 0 };
  snake.over = false;
  snake.score = 0;
  snake.running = false;
  snake.bonus.active = false;
  snake.bonusCooldown = 0;
  snake.speedDelay = snake.speedValue;
  placeFood();
  snakeSpeedInput.value = String(snake.speedValue);
  updateSnakeSpeedLabel(snake.speedValue);
  updateStatus('Ë¥™ÂêÉËõá', 'ÁÇπÂáªÊ£ãÁõòÂºÄÂßãÔºåÂÜçÁî®ÊñπÂêëÈîÆÊàñÊªëÂä®');
  updateLegend(['ÂêÉÈ£üÁâ©ÂèòÈïø', 'ÊíûÂà∞Ëá™Â∑±ÁªìÊùü', 'ÂèØÁ©øË∂äËæπÁïå']);
}

function buildSnakeWalls(levelIndex) {
  const coords = snakeLevels[levelIndex] || [];
  const set = new Set();
  coords.forEach(([x, y]) => {
    set.add(`${x},${y}`);
  });
  return set;
}

function findSnakeSpawn() {
  for (let y = 2; y < snake.grid - 2; y += 1) {
    for (let x = 2; x < snake.grid - 4; x += 1) {
      const keys = [
        `${x},${y}`,
        `${x + 1},${y}`,
        `${x + 2},${y}`
      ];
      if (keys.every((k) => !snake.walls.has(k))) {
        return { x, y };
      }
    }
  }
  return { x: 2, y: 2 };
}

function placeFood() {
  const cells = [];
  for (let y = 0; y < snake.grid; y += 1) {
    for (let x = 0; x < snake.grid; x += 1) {
      const key = `${x},${y}`;
      const isBonus = snake.bonus.active && snake.bonus.x === x && snake.bonus.y === y;
      if (!snake.body.some((p) => p.x === x && p.y === y) && !snake.walls.has(key) && !isBonus) {
        cells.push({ x, y });
      }
    }
  }
  snake.food = cells[Math.floor(Math.random() * cells.length)];
}

function spawnBonus() {
  const cells = [];
  for (let y = 0; y < snake.grid; y += 1) {
    for (let x = 0; x < snake.grid; x += 1) {
      const key = `${x},${y}`;
      const isBody = snake.body.some((p) => p.x === x && p.y === y);
      const isFood = snake.food.x === x && snake.food.y === y;
      if (!isBody && !isFood && !snake.walls.has(key)) {
        cells.push({ x, y });
      }
    }
  }
  if (cells.length === 0) return;
  const pick = cells[Math.floor(Math.random() * cells.length)];
  snake.bonus.active = true;
  snake.bonus.x = pick.x;
  snake.bonus.y = pick.y;
  snake.bonus.maxTtl = Math.max(10, Math.round(10000 / snake.speedDelay));
  snake.bonus.ttl = snake.bonus.maxTtl;
}

function updateSnake() {
  if (snake.over || !snake.running) return;
  snake.dir = { ...snake.nextDir };
  const head = snake.body[0];
  let nx = head.x + snake.dir.x;
  let ny = head.y + snake.dir.y;
  if (nx < 0) nx = snake.grid - 1;
  if (nx >= snake.grid) nx = 0;
  if (ny < 0) ny = snake.grid - 1;
  if (ny >= snake.grid) ny = 0;
  const next = { x: nx, y: ny };
  if (snake.walls.has(`${next.x},${next.y}`)) {
    snake.over = true;
    updateStatus('Ê∏∏ÊàèÁªìÊùü', `ÂæóÂàÜÔºö${snake.score}`);
    return;
  }
  if (snake.body.some((p) => p.x === next.x && p.y === next.y)) {
    snake.over = true;
    updateStatus('Ê∏∏ÊàèÁªìÊùü', `ÂæóÂàÜÔºö${snake.score}`);
    return;
  }

  if (snake.bonus.active) {
    snake.bonus.ttl -= 1;
    if (snake.bonus.ttl <= 0) {
      snake.bonus.active = false;
    }
  } else if (snake.bonusCooldown > 0) {
    snake.bonusCooldown -= 1;
  } else if (Math.random() < 0.02) {
    spawnBonus();
  }

  snake.body.unshift(next);
  if (next.x === snake.food.x && next.y === snake.food.y) {
    snake.score += 1;
    placeFood();
  } else {
    snake.body.pop();
  }

  if (snake.bonus.active && next.x === snake.bonus.x && next.y === snake.bonus.y) {
    const ratio = snake.bonus.ttl / snake.bonus.maxTtl;
    const bonusScore = Math.max(1, Math.ceil(10 * ratio));
    snake.score += bonusScore;
    snake.bonus.active = false;
    snake.bonusCooldown = 40;
  }
  updateStatus(`ÂæóÂàÜÔºö${snake.score}`, '‰ΩøÁî®ÊñπÂêëÈîÆÊàñÊªëÂä®ÁßªÂä®');
}

function drawSnake() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#eef3ff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const cell = canvas.width / snake.grid;
  ctx.fillStyle = '#2f2f2f';
  snake.walls.forEach((key) => {
    const [x, y] = key.split(',').map(Number);
    ctx.fillRect(x * cell, y * cell, cell, cell);
  });

  ctx.fillStyle = '#ff6f5c';
  ctx.beginPath();
  ctx.arc((snake.food.x + 0.5) * cell, (snake.food.y + 0.5) * cell, cell * 0.35, 0, Math.PI * 2);
  ctx.fill();

  if (snake.bonus.active) {
    const bx = (snake.bonus.x + 0.5) * cell;
    const by = (snake.bonus.y + 0.5) * cell;
    const radius = cell * 0.32;
    const grad = ctx.createRadialGradient(bx, by, 2, bx, by, radius);
    grad.addColorStop(0, '#fff3b0');
    grad.addColorStop(1, '#f59e0b');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(bx, by, radius, 0, Math.PI * 2);
    ctx.fill();
    const ratio = snake.bonus.ttl / snake.bonus.maxTtl;
    ctx.strokeStyle = '#b45309';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(bx, by, radius + 4, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * ratio);
    ctx.stroke();
  }

  const bodyGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  bodyGradient.addColorStop(0, '#2a6df4');
  bodyGradient.addColorStop(1, '#60a5fa');
  snake.body.forEach((p, i) => {
    if (i === 0) {
      const emoji = snake.over ? 'üíÄ' : 'üòä';
      ctx.font = `${Math.floor(cell * 0.7)}px 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(emoji, (p.x + 0.5) * cell, (p.y + 0.5) * cell);
    } else {
      ctx.fillStyle = bodyGradient;
      const rx = p.x * cell + cell * 0.12;
      const ry = p.y * cell + cell * 0.12;
      const size = cell * 0.76;
      const r = cell * 0.2;
      ctx.beginPath();
      ctx.moveTo(rx + r, ry);
      ctx.arcTo(rx + size, ry, rx + size, ry + size, r);
      ctx.arcTo(rx + size, ry + size, rx, ry + size, r);
      ctx.arcTo(rx, ry + size, rx, ry, r);
      ctx.arcTo(rx, ry, rx + size, ry, r);
      ctx.closePath();
      ctx.fill();
    }
  });

  ctx.strokeStyle = '#dbe2f3';
  for (let i = 0; i <= snake.grid; i += 1) {
    ctx.beginPath();
    ctx.moveTo(0, i * cell);
    ctx.lineTo(canvas.width, i * cell);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(i * cell, 0);
    ctx.lineTo(i * cell, canvas.height);
    ctx.stroke();
  }
}

function startSnakeLoop() {
  clearInterval(snakeTimer);
  snakeTimer = setInterval(() => {
    updateSnake();
    draw();
  }, snake.speedDelay);
}

function setSnakeDirection(x, y) {
  if (snake.dir.x + x === 0 && snake.dir.y + y === 0) return;
  snake.nextDir = { x, y };
  snake.running = true;
}

function updateSnakeSpeedLabel(value) {
  const v = Number(value);
  if (v <= 90) snakeSpeedValue.textContent = 'Âø´ÈÄü';
  else if (v <= 140) snakeSpeedValue.textContent = '‰∏≠ÈÄü';
  else snakeSpeedValue.textContent = 'ÊÖ¢ÈÄü';
}

function updateStatus(main, hint) {
  statusText.textContent = main;
  hintText.textContent = hint;
}

function updateLegend(items) {
  legend.innerHTML = '';
  items.forEach((item) => {
    const p = document.createElement('div');
    p.textContent = `‚Ä¢ ${item}`;
    legend.appendChild(p);
  });
}

function draw() {
  drawSnake();
}

snakeControls.addEventListener('click', (event) => {
  const btn = event.target.closest('.ctrl');
  if (!btn) return;
  const dir = btn.dataset.dir;
  if (dir === 'up') setSnakeDirection(0, -1);
  if (dir === 'down') setSnakeDirection(0, 1);
  if (dir === 'left') setSnakeDirection(-1, 0);
  if (dir === 'right') setSnakeDirection(1, 0);
});

snakeSpeedInput.addEventListener('input', () => {
  snake.speedValue = Number(snakeSpeedInput.value);
  snake.speedDelay = snake.speedValue;
  updateSnakeSpeedLabel(snake.speedValue);
  startSnakeLoop();
});

snakeMapSelect.addEventListener('change', () => {
  snake.levelIndex = Number(snakeMapSelect.value);
  initSnake();
  draw();
});

canvas.addEventListener('click', () => {
  if (snake.over) return;
  snake.running = true;
  updateStatus(`ÂæóÂàÜÔºö${snake.score}`, '‰ΩøÁî®ÊñπÂêëÈîÆÊàñÊªëÂä®ÁßªÂä®');
});

canvas.addEventListener('touchstart', (event) => {
  const touch = event.touches[0];
  touchStart = { x: touch.clientX, y: touch.clientY };
});

canvas.addEventListener('touchmove', (event) => {
  if (!touchStart) return;
  const touch = event.touches[0];
  const dx = touch.clientX - touchStart.x;
  const dy = touch.clientY - touchStart.y;
  if (Math.abs(dx) > 25 || Math.abs(dy) > 25) {
    if (Math.abs(dx) > Math.abs(dy)) {
      setSnakeDirection(dx > 0 ? 1 : -1, 0);
    } else {
      setSnakeDirection(0, dy > 0 ? 1 : -1);
    }
    touchStart = null;
  }
  event.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', () => {
  touchStart = null;
});

window.addEventListener('keydown', (event) => {
  if (event.key === 'ArrowUp') setSnakeDirection(0, -1);
  if (event.key === 'ArrowDown') setSnakeDirection(0, 1);
  if (event.key === 'ArrowLeft') setSnakeDirection(-1, 0);
  if (event.key === 'ArrowRight') setSnakeDirection(1, 0);
});

resetBtn.addEventListener('click', () => {
  initSnake();
  draw();
});

rulesBtn.addEventListener('click', () => {
  ruleBody.textContent = rules;
  rulePanel.classList.add('show');
  rulePanel.setAttribute('aria-hidden', 'false');
});

closeRule.addEventListener('click', () => {
  rulePanel.classList.remove('show');
  rulePanel.setAttribute('aria-hidden', 'true');
});

function initSnakeMapOptions() {
  snakeMapSelect.innerHTML = '';
  snakeLevels.forEach((_, index) => {
    const option = document.createElement('option');
    option.value = String(index);
    option.textContent = `Âú∞Âõæ ${index + 1}`;
    if (index === snake.levelIndex) option.selected = true;
    snakeMapSelect.appendChild(option);
  });
}

requestAnimationFrame(() => {
  setCanvasSize();
  initSnakeMapOptions();
  updateSnakeSpeedLabel(snake.speedValue);
  initSnake();
  draw();
  startSnakeLoop();
});
